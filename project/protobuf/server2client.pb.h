// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: server2client.proto

#ifndef PROTOBUF_INCLUDED_server2client_2eproto
#define PROTOBUF_INCLUDED_server2client_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_server2client_2eproto 

namespace protobuf_server2client_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[5];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_server2client_2eproto
namespace server2client {
class HexagonCoordinate;
class HexagonCoordinateDefaultTypeInternal;
extern HexagonCoordinateDefaultTypeInternal _HexagonCoordinate_default_instance_;
class HexagonProperty;
class HexagonPropertyDefaultTypeInternal;
extern HexagonPropertyDefaultTypeInternal _HexagonProperty_default_instance_;
class Packet;
class PacketDefaultTypeInternal;
extern PacketDefaultTypeInternal _Packet_default_instance_;
class Player;
class PlayerDefaultTypeInternal;
extern PlayerDefaultTypeInternal _Player_default_instance_;
class TailProperty;
class TailPropertyDefaultTypeInternal;
extern TailPropertyDefaultTypeInternal _TailProperty_default_instance_;
}  // namespace server2client
namespace google {
namespace protobuf {
template<> ::server2client::HexagonCoordinate* Arena::CreateMaybeMessage<::server2client::HexagonCoordinate>(Arena*);
template<> ::server2client::HexagonProperty* Arena::CreateMaybeMessage<::server2client::HexagonProperty>(Arena*);
template<> ::server2client::Packet* Arena::CreateMaybeMessage<::server2client::Packet>(Arena*);
template<> ::server2client::Player* Arena::CreateMaybeMessage<::server2client::Player>(Arena*);
template<> ::server2client::TailProperty* Arena::CreateMaybeMessage<::server2client::TailProperty>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace server2client {

enum Move {
  UP = 0,
  RIGHT_UP = 1,
  RIGHT_DOWN = 2,
  DOWN = 3,
  LEFT_DOWN = 4,
  LEFT_UP = 5
};
bool Move_IsValid(int value);
const Move Move_MIN = UP;
const Move Move_MAX = LEFT_UP;
const int Move_ARRAYSIZE = Move_MAX + 1;

const ::google::protobuf::EnumDescriptor* Move_descriptor();
inline const ::std::string& Move_Name(Move value) {
  return ::google::protobuf::internal::NameOfEnum(
    Move_descriptor(), value);
}
inline bool Move_Parse(
    const ::std::string& name, Move* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Move>(
    Move_descriptor(), name, value);
}
// ===================================================================

class HexagonCoordinate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server2client.HexagonCoordinate) */ {
 public:
  HexagonCoordinate();
  virtual ~HexagonCoordinate();

  HexagonCoordinate(const HexagonCoordinate& from);

  inline HexagonCoordinate& operator=(const HexagonCoordinate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HexagonCoordinate(HexagonCoordinate&& from) noexcept
    : HexagonCoordinate() {
    *this = ::std::move(from);
  }

  inline HexagonCoordinate& operator=(HexagonCoordinate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HexagonCoordinate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HexagonCoordinate* internal_default_instance() {
    return reinterpret_cast<const HexagonCoordinate*>(
               &_HexagonCoordinate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(HexagonCoordinate* other);
  friend void swap(HexagonCoordinate& a, HexagonCoordinate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HexagonCoordinate* New() const final {
    return CreateMaybeMessage<HexagonCoordinate>(NULL);
  }

  HexagonCoordinate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HexagonCoordinate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HexagonCoordinate& from);
  void MergeFrom(const HexagonCoordinate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HexagonCoordinate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 q = 1;
  bool has_q() const;
  void clear_q();
  static const int kQFieldNumber = 1;
  ::google::protobuf::int32 q() const;
  void set_q(::google::protobuf::int32 value);

  // required int32 r = 2;
  bool has_r() const;
  void clear_r();
  static const int kRFieldNumber = 2;
  ::google::protobuf::int32 r() const;
  void set_r(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:server2client.HexagonCoordinate)
 private:
  void set_has_q();
  void clear_has_q();
  void set_has_r();
  void clear_has_r();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 q_;
  ::google::protobuf::int32 r_;
  friend struct ::protobuf_server2client_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HexagonProperty : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server2client.HexagonProperty) */ {
 public:
  HexagonProperty();
  virtual ~HexagonProperty();

  HexagonProperty(const HexagonProperty& from);

  inline HexagonProperty& operator=(const HexagonProperty& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HexagonProperty(HexagonProperty&& from) noexcept
    : HexagonProperty() {
    *this = ::std::move(from);
  }

  inline HexagonProperty& operator=(HexagonProperty&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HexagonProperty& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HexagonProperty* internal_default_instance() {
    return reinterpret_cast<const HexagonProperty*>(
               &_HexagonProperty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(HexagonProperty* other);
  friend void swap(HexagonProperty& a, HexagonProperty& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HexagonProperty* New() const final {
    return CreateMaybeMessage<HexagonProperty>(NULL);
  }

  HexagonProperty* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HexagonProperty>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HexagonProperty& from);
  void MergeFrom(const HexagonProperty& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HexagonProperty* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .server2client.HexagonCoordinate hex = 1;
  bool has_hex() const;
  void clear_hex();
  static const int kHexFieldNumber = 1;
  private:
  const ::server2client::HexagonCoordinate& _internal_hex() const;
  public:
  const ::server2client::HexagonCoordinate& hex() const;
  ::server2client::HexagonCoordinate* release_hex();
  ::server2client::HexagonCoordinate* mutable_hex();
  void set_allocated_hex(::server2client::HexagonCoordinate* hex);

  // required int32 id = 2;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 2;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:server2client.HexagonProperty)
 private:
  void set_has_hex();
  void clear_has_hex();
  void set_has_id();
  void clear_has_id();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::server2client::HexagonCoordinate* hex_;
  ::google::protobuf::int32 id_;
  friend struct ::protobuf_server2client_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TailProperty : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server2client.TailProperty) */ {
 public:
  TailProperty();
  virtual ~TailProperty();

  TailProperty(const TailProperty& from);

  inline TailProperty& operator=(const TailProperty& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TailProperty(TailProperty&& from) noexcept
    : TailProperty() {
    *this = ::std::move(from);
  }

  inline TailProperty& operator=(TailProperty&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TailProperty& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TailProperty* internal_default_instance() {
    return reinterpret_cast<const TailProperty*>(
               &_TailProperty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(TailProperty* other);
  friend void swap(TailProperty& a, TailProperty& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TailProperty* New() const final {
    return CreateMaybeMessage<TailProperty>(NULL);
  }

  TailProperty* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TailProperty>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TailProperty& from);
  void MergeFrom(const TailProperty& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TailProperty* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .server2client.HexagonCoordinate hex = 1;
  bool has_hex() const;
  void clear_hex();
  static const int kHexFieldNumber = 1;
  private:
  const ::server2client::HexagonCoordinate& _internal_hex() const;
  public:
  const ::server2client::HexagonCoordinate& hex() const;
  ::server2client::HexagonCoordinate* release_hex();
  ::server2client::HexagonCoordinate* mutable_hex();
  void set_allocated_hex(::server2client::HexagonCoordinate* hex);

  // required .server2client.Move direction = 2;
  bool has_direction() const;
  void clear_direction();
  static const int kDirectionFieldNumber = 2;
  ::server2client::Move direction() const;
  void set_direction(::server2client::Move value);

  // required int32 id = 3;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 3;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:server2client.TailProperty)
 private:
  void set_has_hex();
  void clear_has_hex();
  void set_has_direction();
  void clear_has_direction();
  void set_has_id();
  void clear_has_id();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::server2client::HexagonCoordinate* hex_;
  int direction_;
  ::google::protobuf::int32 id_;
  friend struct ::protobuf_server2client_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Player : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server2client.Player) */ {
 public:
  Player();
  virtual ~Player();

  Player(const Player& from);

  inline Player& operator=(const Player& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Player(Player&& from) noexcept
    : Player() {
    *this = ::std::move(from);
  }

  inline Player& operator=(Player&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Player& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Player* internal_default_instance() {
    return reinterpret_cast<const Player*>(
               &_Player_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Player* other);
  friend void swap(Player& a, Player& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Player* New() const final {
    return CreateMaybeMessage<Player>(NULL);
  }

  Player* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Player>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Player& from);
  void MergeFrom(const Player& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Player* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .server2client.HexagonCoordinate position = 3;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 3;
  private:
  const ::server2client::HexagonCoordinate& _internal_position() const;
  public:
  const ::server2client::HexagonCoordinate& position() const;
  ::server2client::HexagonCoordinate* release_position();
  ::server2client::HexagonCoordinate* mutable_position();
  void set_allocated_position(::server2client::HexagonCoordinate* position);

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required .server2client.Move direction = 2;
  bool has_direction() const;
  void clear_direction();
  static const int kDirectionFieldNumber = 2;
  ::server2client::Move direction() const;
  void set_direction(::server2client::Move value);

  // required int32 expansion = 4;
  bool has_expansion() const;
  void clear_expansion();
  static const int kExpansionFieldNumber = 4;
  ::google::protobuf::int32 expansion() const;
  void set_expansion(::google::protobuf::int32 value);

  // required int32 kills = 5;
  bool has_kills() const;
  void clear_kills();
  static const int kKillsFieldNumber = 5;
  ::google::protobuf::int32 kills() const;
  void set_kills(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:server2client.Player)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_direction();
  void clear_has_direction();
  void set_has_position();
  void clear_has_position();
  void set_has_expansion();
  void clear_has_expansion();
  void set_has_kills();
  void clear_has_kills();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::server2client::HexagonCoordinate* position_;
  ::google::protobuf::int32 id_;
  int direction_;
  ::google::protobuf::int32 expansion_;
  ::google::protobuf::int32 kills_;
  friend struct ::protobuf_server2client_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Packet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:server2client.Packet) */ {
 public:
  Packet();
  virtual ~Packet();

  Packet(const Packet& from);

  inline Packet& operator=(const Packet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Packet(Packet&& from) noexcept
    : Packet() {
    *this = ::std::move(from);
  }

  inline Packet& operator=(Packet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Packet* internal_default_instance() {
    return reinterpret_cast<const Packet*>(
               &_Packet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Packet* other);
  friend void swap(Packet& a, Packet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Packet* New() const final {
    return CreateMaybeMessage<Packet>(NULL);
  }

  Packet* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Packet>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Packet& from);
  void MergeFrom(const Packet& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Packet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .server2client.Player players = 1;
  int players_size() const;
  void clear_players();
  static const int kPlayersFieldNumber = 1;
  ::server2client::Player* mutable_players(int index);
  ::google::protobuf::RepeatedPtrField< ::server2client::Player >*
      mutable_players();
  const ::server2client::Player& players(int index) const;
  ::server2client::Player* add_players();
  const ::google::protobuf::RepeatedPtrField< ::server2client::Player >&
      players() const;

  // repeated .server2client.HexagonProperty areas = 2;
  int areas_size() const;
  void clear_areas();
  static const int kAreasFieldNumber = 2;
  ::server2client::HexagonProperty* mutable_areas(int index);
  ::google::protobuf::RepeatedPtrField< ::server2client::HexagonProperty >*
      mutable_areas();
  const ::server2client::HexagonProperty& areas(int index) const;
  ::server2client::HexagonProperty* add_areas();
  const ::google::protobuf::RepeatedPtrField< ::server2client::HexagonProperty >&
      areas() const;

  // repeated .server2client.HexagonProperty tails = 3;
  int tails_size() const;
  void clear_tails();
  static const int kTailsFieldNumber = 3;
  ::server2client::HexagonProperty* mutable_tails(int index);
  ::google::protobuf::RepeatedPtrField< ::server2client::HexagonProperty >*
      mutable_tails();
  const ::server2client::HexagonProperty& tails(int index) const;
  ::server2client::HexagonProperty* add_tails();
  const ::google::protobuf::RepeatedPtrField< ::server2client::HexagonProperty >&
      tails() const;

  // @@protoc_insertion_point(class_scope:server2client.Packet)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::server2client::Player > players_;
  ::google::protobuf::RepeatedPtrField< ::server2client::HexagonProperty > areas_;
  ::google::protobuf::RepeatedPtrField< ::server2client::HexagonProperty > tails_;
  friend struct ::protobuf_server2client_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HexagonCoordinate

// required int32 q = 1;
inline bool HexagonCoordinate::has_q() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HexagonCoordinate::set_has_q() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HexagonCoordinate::clear_has_q() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HexagonCoordinate::clear_q() {
  q_ = 0;
  clear_has_q();
}
inline ::google::protobuf::int32 HexagonCoordinate::q() const {
  // @@protoc_insertion_point(field_get:server2client.HexagonCoordinate.q)
  return q_;
}
inline void HexagonCoordinate::set_q(::google::protobuf::int32 value) {
  set_has_q();
  q_ = value;
  // @@protoc_insertion_point(field_set:server2client.HexagonCoordinate.q)
}

// required int32 r = 2;
inline bool HexagonCoordinate::has_r() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HexagonCoordinate::set_has_r() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HexagonCoordinate::clear_has_r() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HexagonCoordinate::clear_r() {
  r_ = 0;
  clear_has_r();
}
inline ::google::protobuf::int32 HexagonCoordinate::r() const {
  // @@protoc_insertion_point(field_get:server2client.HexagonCoordinate.r)
  return r_;
}
inline void HexagonCoordinate::set_r(::google::protobuf::int32 value) {
  set_has_r();
  r_ = value;
  // @@protoc_insertion_point(field_set:server2client.HexagonCoordinate.r)
}

// -------------------------------------------------------------------

// HexagonProperty

// required .server2client.HexagonCoordinate hex = 1;
inline bool HexagonProperty::has_hex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HexagonProperty::set_has_hex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HexagonProperty::clear_has_hex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HexagonProperty::clear_hex() {
  if (hex_ != NULL) hex_->Clear();
  clear_has_hex();
}
inline const ::server2client::HexagonCoordinate& HexagonProperty::_internal_hex() const {
  return *hex_;
}
inline const ::server2client::HexagonCoordinate& HexagonProperty::hex() const {
  const ::server2client::HexagonCoordinate* p = hex_;
  // @@protoc_insertion_point(field_get:server2client.HexagonProperty.hex)
  return p != NULL ? *p : *reinterpret_cast<const ::server2client::HexagonCoordinate*>(
      &::server2client::_HexagonCoordinate_default_instance_);
}
inline ::server2client::HexagonCoordinate* HexagonProperty::release_hex() {
  // @@protoc_insertion_point(field_release:server2client.HexagonProperty.hex)
  clear_has_hex();
  ::server2client::HexagonCoordinate* temp = hex_;
  hex_ = NULL;
  return temp;
}
inline ::server2client::HexagonCoordinate* HexagonProperty::mutable_hex() {
  set_has_hex();
  if (hex_ == NULL) {
    auto* p = CreateMaybeMessage<::server2client::HexagonCoordinate>(GetArenaNoVirtual());
    hex_ = p;
  }
  // @@protoc_insertion_point(field_mutable:server2client.HexagonProperty.hex)
  return hex_;
}
inline void HexagonProperty::set_allocated_hex(::server2client::HexagonCoordinate* hex) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete hex_;
  }
  if (hex) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      hex = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, hex, submessage_arena);
    }
    set_has_hex();
  } else {
    clear_has_hex();
  }
  hex_ = hex;
  // @@protoc_insertion_point(field_set_allocated:server2client.HexagonProperty.hex)
}

// required int32 id = 2;
inline bool HexagonProperty::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HexagonProperty::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HexagonProperty::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HexagonProperty::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 HexagonProperty::id() const {
  // @@protoc_insertion_point(field_get:server2client.HexagonProperty.id)
  return id_;
}
inline void HexagonProperty::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:server2client.HexagonProperty.id)
}

// -------------------------------------------------------------------

// TailProperty

// required .server2client.HexagonCoordinate hex = 1;
inline bool TailProperty::has_hex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TailProperty::set_has_hex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TailProperty::clear_has_hex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TailProperty::clear_hex() {
  if (hex_ != NULL) hex_->Clear();
  clear_has_hex();
}
inline const ::server2client::HexagonCoordinate& TailProperty::_internal_hex() const {
  return *hex_;
}
inline const ::server2client::HexagonCoordinate& TailProperty::hex() const {
  const ::server2client::HexagonCoordinate* p = hex_;
  // @@protoc_insertion_point(field_get:server2client.TailProperty.hex)
  return p != NULL ? *p : *reinterpret_cast<const ::server2client::HexagonCoordinate*>(
      &::server2client::_HexagonCoordinate_default_instance_);
}
inline ::server2client::HexagonCoordinate* TailProperty::release_hex() {
  // @@protoc_insertion_point(field_release:server2client.TailProperty.hex)
  clear_has_hex();
  ::server2client::HexagonCoordinate* temp = hex_;
  hex_ = NULL;
  return temp;
}
inline ::server2client::HexagonCoordinate* TailProperty::mutable_hex() {
  set_has_hex();
  if (hex_ == NULL) {
    auto* p = CreateMaybeMessage<::server2client::HexagonCoordinate>(GetArenaNoVirtual());
    hex_ = p;
  }
  // @@protoc_insertion_point(field_mutable:server2client.TailProperty.hex)
  return hex_;
}
inline void TailProperty::set_allocated_hex(::server2client::HexagonCoordinate* hex) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete hex_;
  }
  if (hex) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      hex = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, hex, submessage_arena);
    }
    set_has_hex();
  } else {
    clear_has_hex();
  }
  hex_ = hex;
  // @@protoc_insertion_point(field_set_allocated:server2client.TailProperty.hex)
}

// required .server2client.Move direction = 2;
inline bool TailProperty::has_direction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TailProperty::set_has_direction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TailProperty::clear_has_direction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TailProperty::clear_direction() {
  direction_ = 0;
  clear_has_direction();
}
inline ::server2client::Move TailProperty::direction() const {
  // @@protoc_insertion_point(field_get:server2client.TailProperty.direction)
  return static_cast< ::server2client::Move >(direction_);
}
inline void TailProperty::set_direction(::server2client::Move value) {
  assert(::server2client::Move_IsValid(value));
  set_has_direction();
  direction_ = value;
  // @@protoc_insertion_point(field_set:server2client.TailProperty.direction)
}

// required int32 id = 3;
inline bool TailProperty::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TailProperty::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TailProperty::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TailProperty::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 TailProperty::id() const {
  // @@protoc_insertion_point(field_get:server2client.TailProperty.id)
  return id_;
}
inline void TailProperty::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:server2client.TailProperty.id)
}

// -------------------------------------------------------------------

// Player

// required int32 id = 1;
inline bool Player::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Player::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Player::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Player::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Player::id() const {
  // @@protoc_insertion_point(field_get:server2client.Player.id)
  return id_;
}
inline void Player::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:server2client.Player.id)
}

// required .server2client.Move direction = 2;
inline bool Player::has_direction() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Player::set_has_direction() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Player::clear_has_direction() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Player::clear_direction() {
  direction_ = 0;
  clear_has_direction();
}
inline ::server2client::Move Player::direction() const {
  // @@protoc_insertion_point(field_get:server2client.Player.direction)
  return static_cast< ::server2client::Move >(direction_);
}
inline void Player::set_direction(::server2client::Move value) {
  assert(::server2client::Move_IsValid(value));
  set_has_direction();
  direction_ = value;
  // @@protoc_insertion_point(field_set:server2client.Player.direction)
}

// required .server2client.HexagonCoordinate position = 3;
inline bool Player::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Player::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Player::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Player::clear_position() {
  if (position_ != NULL) position_->Clear();
  clear_has_position();
}
inline const ::server2client::HexagonCoordinate& Player::_internal_position() const {
  return *position_;
}
inline const ::server2client::HexagonCoordinate& Player::position() const {
  const ::server2client::HexagonCoordinate* p = position_;
  // @@protoc_insertion_point(field_get:server2client.Player.position)
  return p != NULL ? *p : *reinterpret_cast<const ::server2client::HexagonCoordinate*>(
      &::server2client::_HexagonCoordinate_default_instance_);
}
inline ::server2client::HexagonCoordinate* Player::release_position() {
  // @@protoc_insertion_point(field_release:server2client.Player.position)
  clear_has_position();
  ::server2client::HexagonCoordinate* temp = position_;
  position_ = NULL;
  return temp;
}
inline ::server2client::HexagonCoordinate* Player::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    auto* p = CreateMaybeMessage<::server2client::HexagonCoordinate>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:server2client.Player.position)
  return position_;
}
inline void Player::set_allocated_position(::server2client::HexagonCoordinate* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete position_;
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    set_has_position();
  } else {
    clear_has_position();
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:server2client.Player.position)
}

// required int32 expansion = 4;
inline bool Player::has_expansion() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Player::set_has_expansion() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Player::clear_has_expansion() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Player::clear_expansion() {
  expansion_ = 0;
  clear_has_expansion();
}
inline ::google::protobuf::int32 Player::expansion() const {
  // @@protoc_insertion_point(field_get:server2client.Player.expansion)
  return expansion_;
}
inline void Player::set_expansion(::google::protobuf::int32 value) {
  set_has_expansion();
  expansion_ = value;
  // @@protoc_insertion_point(field_set:server2client.Player.expansion)
}

// required int32 kills = 5;
inline bool Player::has_kills() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Player::set_has_kills() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Player::clear_has_kills() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Player::clear_kills() {
  kills_ = 0;
  clear_has_kills();
}
inline ::google::protobuf::int32 Player::kills() const {
  // @@protoc_insertion_point(field_get:server2client.Player.kills)
  return kills_;
}
inline void Player::set_kills(::google::protobuf::int32 value) {
  set_has_kills();
  kills_ = value;
  // @@protoc_insertion_point(field_set:server2client.Player.kills)
}

// -------------------------------------------------------------------

// Packet

// repeated .server2client.Player players = 1;
inline int Packet::players_size() const {
  return players_.size();
}
inline void Packet::clear_players() {
  players_.Clear();
}
inline ::server2client::Player* Packet::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:server2client.Packet.players)
  return players_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::server2client::Player >*
Packet::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:server2client.Packet.players)
  return &players_;
}
inline const ::server2client::Player& Packet::players(int index) const {
  // @@protoc_insertion_point(field_get:server2client.Packet.players)
  return players_.Get(index);
}
inline ::server2client::Player* Packet::add_players() {
  // @@protoc_insertion_point(field_add:server2client.Packet.players)
  return players_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server2client::Player >&
Packet::players() const {
  // @@protoc_insertion_point(field_list:server2client.Packet.players)
  return players_;
}

// repeated .server2client.HexagonProperty areas = 2;
inline int Packet::areas_size() const {
  return areas_.size();
}
inline void Packet::clear_areas() {
  areas_.Clear();
}
inline ::server2client::HexagonProperty* Packet::mutable_areas(int index) {
  // @@protoc_insertion_point(field_mutable:server2client.Packet.areas)
  return areas_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::server2client::HexagonProperty >*
Packet::mutable_areas() {
  // @@protoc_insertion_point(field_mutable_list:server2client.Packet.areas)
  return &areas_;
}
inline const ::server2client::HexagonProperty& Packet::areas(int index) const {
  // @@protoc_insertion_point(field_get:server2client.Packet.areas)
  return areas_.Get(index);
}
inline ::server2client::HexagonProperty* Packet::add_areas() {
  // @@protoc_insertion_point(field_add:server2client.Packet.areas)
  return areas_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server2client::HexagonProperty >&
Packet::areas() const {
  // @@protoc_insertion_point(field_list:server2client.Packet.areas)
  return areas_;
}

// repeated .server2client.HexagonProperty tails = 3;
inline int Packet::tails_size() const {
  return tails_.size();
}
inline void Packet::clear_tails() {
  tails_.Clear();
}
inline ::server2client::HexagonProperty* Packet::mutable_tails(int index) {
  // @@protoc_insertion_point(field_mutable:server2client.Packet.tails)
  return tails_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::server2client::HexagonProperty >*
Packet::mutable_tails() {
  // @@protoc_insertion_point(field_mutable_list:server2client.Packet.tails)
  return &tails_;
}
inline const ::server2client::HexagonProperty& Packet::tails(int index) const {
  // @@protoc_insertion_point(field_get:server2client.Packet.tails)
  return tails_.Get(index);
}
inline ::server2client::HexagonProperty* Packet::add_tails() {
  // @@protoc_insertion_point(field_add:server2client.Packet.tails)
  return tails_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::server2client::HexagonProperty >&
Packet::tails() const {
  // @@protoc_insertion_point(field_list:server2client.Packet.tails)
  return tails_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace server2client

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::server2client::Move> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::server2client::Move>() {
  return ::server2client::Move_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_server2client_2eproto
